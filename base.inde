data Nat {
    Zero : Nat
    Suc : Nat -> Nat
}

data Vec : Type1 -> Nat -> Type1 {
    Empty : (t:Type1) -> Vec t Zero
    Cons : (t:Type1) -> (n:Nat) -> t -> Vec t n -> Vec t (n+1)
}

native Int : Type1
native Bool : Type1
native true : Bool
native false : Bool
native eq : {t:Type1} -> t -> t -> Bool
{*
//web pages that use InDependent should load this script and Ramda (http://ramdajs.com/)
function Universe(i){
    return new $PRIMUniverse(i)
}

function $PRIMUniverse(i){
    this[0] = "1"
    this[1] = i
    this.__defineGetter__("inDeType", function(){ //TODO: best name for type property?
        return Universe(i+1)
    });
}

function PiType(at,rt){
    return new $PRIMPiType(at, rt)
}

function $PRIMPiType(at, rt){
    this[0] = "2"
    this[1] = at
    this[2] = rt
    this.__defineGetter__("inDeType", function(){
        return Math.max(at.InDeType[1], rt.InDeType[1])
    });
}

//tests whether a and b are structurally equivalent
var eq = R.curry(function(a,b){ //TODO: BIG: how to make sure args are not functions (or in other words, make sure they ARE comparable via equals... Haskell-style instances come to mind)
    if(a.constructor === b.constructor){
        if(a.indeType !== undefined && b.indeType !== undefined){
            for(var i = 0; i <= a[0]; i++){
                if(!eq(a[i], b[i])){
                     return false;
                }
            }
            return true;
        }else{
            return a === b;//primitives and non-InDependent objects rely on JS equality
        }
    }
    
    return false;
    
});

//tests whether obj is an instance of the given ADT constructor
var matchADT = R.curry(function(obj, adt){
    return obj.isInDependent && adt.isInDependent && obj.constructor === adt.constructor
});
*}
